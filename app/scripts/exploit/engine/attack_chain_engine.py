from scripts.exploit.attack_chains.apache import evaluate_apache
# from scripts.exploit.attack_chains.ssh import evaluate_ssh
# from scripts.exploit.attack_chains.ftp import evaluate_ftp


class AttackChainEngine:
    """
    Orchestrateur global des chaÃ®nes dâ€™attaque.

    - Support multi-services
    - Support multi-CVE
    - Ne casse aucun engine existant
    - Retourne UNE attaque finale (la meilleure)
    """

    def __init__(self):
        self.engines = {
            "apache": evaluate_apache,
            # "ssh": evaluate_ssh,
            # "ftp": evaluate_ftp,
        }

    def evaluate(self, facts):
        """
        facts = {
            "services": [
                {
                    "service": "Apache",
                    "version": "2.4.65",
                    "validated_cves": [...]
                }
            ],
            "proofs": [...]
        }
        """

        services = facts.get("services", [])
        proofs = list(set(facts.get("proofs", [])))

        attack_candidates = []

        for svc in services:
            service_name = (svc.get("service") or "").lower()
            version = svc.get("version")
            cves = list(set(svc.get("validated_cves", [])))

            engine = self.engines.get(service_name)
            if not engine:
                continue

            for cve in cves:
                unit_facts = {
                    "service": svc.get("service"),
                    "version": version,
                    "validated_cves": [cve],
                    "headers": proofs,
                }

                try:
                    result = engine(unit_facts)
                    if result:
                        attack_candidates.append({
                            "service": svc.get("service"),
                            "version": version,
                            "cve": cve,
                            "attack": result.get("attack"),
                            "confidence": result.get("confidence", 0),
                            "exploit": result.get("exploit"),
                            "proof": proofs,
                        })
                except Exception:
                    continue

        if not attack_candidates:
            return {
                "status": False,
                "impact": "no_attack_chain",
                "proof": "No applicable attack chain found"
            }

        # ðŸ”¥ SÃ©lection de la meilleure attaque
        best = sorted(
            attack_candidates,
            key=lambda x: (x["confidence"], bool(x["exploit"])),
            reverse=True
        )[0]

        return {
            "status": True,
            "impact": "attack_chain_available",
            "service": best["service"],
            "version": best["version"],
            "cve": best["cve"],
            "attack": best["attack"],
            "confidence": best["confidence"],
            "exploit": best["exploit"],
            "proof": best["proof"]
        }
