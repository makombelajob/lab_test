import requests
import re


class SecurityEngine:
    """
    SecurityEngine = Validation technique
    Il vérifie si une CVE détectée est réellement applicable à la cible.

    Il ne lance PAS d'exploit.
    Il confirme juste :
        - le service
        - la version
        - les headers
        - la surface d’attaque
    """

    def __init__(self):
        # CVE → méthodes de validation
        self.cve_modules = {
            # Apache path traversal / RCE
            "CVE-2022-22720": ["apache_fingerprint"],
            "CVE-2022-22721": ["apache_fingerprint"],
            "CVE-2022-23943": ["apache_fingerprint"],
            "CVE-2022-22719": ["apache_fingerprint"],

            # Apache info leak / fingerprinting
            "CVE-2025-58098": ["apache_headers"],
        }

    def search_modules(self, cve_id):
        # Si on ne connaît pas la CVE → validation générique
        return self.cve_modules.get(cve_id, ["generic_fingerprint"])

    def run_module(self, module, target):
        try:
            if module == "apache_fingerprint":
                return self._apache_fingerprint(target)

            if module == "apache_headers":
                return self._apache_headers(target)

            if module == "generic_fingerprint":
                return self._generic_fingerprint(target)

        except Exception as e:
            return {
                "status": "error",
                "proof": str(e),
                "service": None,
                "version": None
            }

        return {
            "status": "not_exploitable",
            "proof": "Unknown module",
            "service": None,
            "version": None
        }

    # ==============================
    # MODULES
    # ==============================

    def _fetch(self, target):
        url = f"http://{target}"
        r = requests.get(url, timeout=5, allow_redirects=True)
        return r

    def _extract_apache_version(self, server_header):
        # Apache/2.4.52 (Debian)
        m = re.search(r'Apache/([\d.]+)', server_header or "")
        if m:
            return m.group(1)
        return None

    # ---- Apache fingerprint (CVE 2022 RCE) ----
    def _apache_fingerprint(self, target):
        r = self._fetch(target)

        server = r.headers.get("Server", "")
        version = self._extract_apache_version(server)

        if "Apache" in server:
            return {
                "status": "exploitable",
                "proof": f"Apache detected: {server}",
                "service": "Apache",
                "version": version,
                "headers": dict(r.headers)
            }

        return {
            "status": "not_exploitable",
            "proof": "Apache not detected",
            "service": None,
            "version": None,
            "headers": dict(r.headers)
        }

    # ---- Apache header leak (CVE‑2025‑58098) ----
    def _apache_headers(self, target):
        r = self._fetch(target)

        server = r.headers.get("Server", "")
        powered = r.headers.get("X-Powered-By", "")

        if server:
            return {
                "status": "exploitable",
                "proof": f"Server={server} | X-Powered-By={powered}",
                "service": "Apache" if "Apache" in server else None,
                "version": self._extract_apache_version(server),
                "headers": dict(r.headers)
            }

        return {
            "status": "not_exploitable",
            "proof": "No Server header exposed",
            "service": None,
            "version": None,
            "headers": dict(r.headers)
        }

    # ---- Generic fingerprint (fallback) ----
    def _generic_fingerprint(self, target):
        r = self._fetch(target)

        server = r.headers.get("Server", "")

        service = None
        version = None

        if "Apache" in server:
            service = "Apache"
            version = self._extract_apache_version(server)
        elif "nginx" in server.lower():
            service = "Nginx"
        elif "iis" in server.lower():
            service = "IIS"

        if server:
            return {
                "status": "exploitable",
                "proof": f"Service fingerprinted: {server}",
                "service": service,
                "version": version,
                "headers": dict(r.headers)
            }

        return {
            "status": "not_exploitable",
            "proof": "No fingerprint possible",
            "service": None,
            "version": None,
            "headers": dict(r.headers)
        }
