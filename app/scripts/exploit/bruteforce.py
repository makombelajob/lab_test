import sys, json, re
from scripts.db.mysql_conn import get_connection
from scripts.exploit.engine.security_engine import SecurityEngine
from scripts.exploit.engine.exploit_engine import ExploitEngine
from scripts.exploit.attack_chains.chain_engine import evaluate_chain
from scripts.exploit.engine.exploit_runner import ExploitRunner


def parse_cves(raw):
    out = []
    if not raw:
        return out

    for p in raw.split(","):
        m = re.match(r'(CVE-\d{4}-\d+)', p.strip())
        if m:
            out.append(m.group(1))
    return out


def main():
    user_id, target = sys.argv[1], sys.argv[2]

    conn = get_connection()
    cur = conn.cursor(dictionary=True)

    # ================= R√âCUP√âRATION SCAN =================
    cur.execute("""
        SELECT scanner.script_vuln, scanner.service, scanner.version
        FROM scanner
        JOIN ping ON scanner.ping_id = ping.id
        WHERE ping.user_id=%s AND ping.ip_address=%s
    """, (user_id, target))

    rows = cur.fetchall()

    print(f"\n==== Exploit de la cible {target} ======\n")

    if not rows:
        print("‚ùå Aucun service exploitable")
        return

    # ================= NORMALISATION DES SERVICES =================
    services = {}
    proofs = []

    for r in rows:
        service = (r["service"] or "").strip()
        version = (r["version"] or "").strip()

        if not service:
            continue

        key = f"{service.lower()}:{version}"

        if key not in services:
            services[key] = {
                "service": service,
                "version": version,
                "validated_cves": set()
            }

    # ================= PHASE 1 : VALIDATION DES CVE =================
    sec = SecurityEngine()

    for key, svc in services.items():
        service = svc["service"]
        version = svc["version"]

        # R√©cup√®re toutes les CVE associ√©es √† ce service/version
        cves = set()
        for r in rows:
            if r["service"] == service and r["version"] == version:
                cves.update(parse_cves(r["script_vuln"]))

        if not cves:
            continue

        print(f"üîç Analyse {service} {version} ‚Üí {len(cves)} CVE")

        for cve in cves:
            modules = sec.search_modules(cve)

            for m in modules:
                res = sec.run_module(m, target)

                if res.get("status") == "exploitable":
                    svc["validated_cves"].add(cve)

                    proof = res.get("proof")
                    if proof:
                        proofs.append(proof)

                    print(f"   ‚úÖ {cve} exploitable via {m}")

    # ================= CONSTRUCTION DES FACTS =================
    facts = {
        "services": [],
        "proofs": list(set(proofs))
    }

    for svc in services.values():
        if svc["validated_cves"]:
            facts["services"].append({
                "service": svc["service"],
                "version": svc["version"],
                "validated_cves": list(svc["validated_cves"])
            })

    if not facts["services"]:
        print("\n‚ùå Aucune CVE exploitable valid√©e")
        return

    print("\nüß† FACTS CONSTRUITS")
    print(json.dumps(facts, indent=2))

    # ================= PHASE 2 : ATTACK CHAIN =================
    chain = None

    for svc in facts["services"]:
        chain = evaluate_chain({
            "service": svc["service"],
            "version": svc["version"],
            "validated_cves": svc["validated_cves"],
            "headers": facts["proofs"]
        })

        if chain:
            break

    print("\n--- ATTACK CHAIN ---")
    print(json.dumps(chain, indent=2))

    if not chain or not chain.get("exploit"):
        print("\n‚ö†Ô∏è Aucune cha√Æne d‚Äôattaque exploitable")
        return

    # ================= PHASE 3 : EXPLOIT R√âEL =================
    print("\nüî• Exploit recommand√© :", chain["exploit"])

    runner = ExploitRunner()
    result = runner.run(chain["exploit"], target)

    #### Store via symfony #######
    clean_proofs = list(dict.fromkeys(proofs))
    exploit_data = {
        "module": chain["exploit"],
        "payload": None,
        "status": result["status"],
        "session_id": None,
        "output": json.dumps(
            result.get("details") or result, indent=2),
        "proof": " | ".join(clean_proofs)
    }
    print("\n@@@EXPLOITJSON@@@")
    print(json.dumps(exploit_data))
    ############# Final print ##############
    #print("\n--- REAL EXPLOIT RESULT ---")
    #print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
