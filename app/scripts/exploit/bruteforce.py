import sys, json, re
from scripts.db.mysql_conn import get_connection
from scripts.exploit.engine.security_engine import SecurityEngine
from scripts.exploit.engine.exploit_engine import ExploitEngine
from scripts.exploit.attack_chains.chain_engine import evaluate_chain
from scripts.exploit.engine.exploit_runner import ExploitRunner


def parse_cves(raw):
    out = []
    for p in raw.split(","):
        m = re.match(r'(CVE-\d{4}-\d+)\(([\d.]+)\|([A-Z]+)\)', p.strip())
        if m:
            out.append(m.group(1))
    return out

def main():
    user_id, target = sys.argv[1], sys.argv[2]

    conn = get_connection()
    cur = conn.cursor(dictionary=True)

    cur.execute("""
        SELECT scanner.script_vuln, scanner.service, scanner.version
        FROM scanner
        JOIN ping ON scanner.ping_id = ping.id
        WHERE ping.user_id=%s AND ping.ip_address=%s
    """, (user_id, target))

    rows = cur.fetchall()

    print(f"\n==== Exploit de la cible {target} ======\n")

    sec = SecurityEngine()
    exp = ExploitEngine()

    all_validated = []
    headers = {}

    # Phase 1 : validation CVE
    for r in rows:
        cves = parse_cves(r["script_vuln"] or "")

        for cve in cves:
            modules = sec.search_modules(cve)
            for m in modules:
                res = sec.run_module(m, target)

                if res["status"] == "exploitable":
                    all_validated.append(cve)
                    if "Server" in res.get("proof", ""):
                        headers["server"] = res["proof"]

    if not all_validated:
        print("‚ùå Aucune CVE exploitable")
        return

    # Phase 2 : construction des faits
    service = rows[0]["service"]
    version = rows[0]["version"]

    facts = {
        "service": service,
        "version": version,
        "validated_cves": list(set(all_validated)),
        "headers": headers
    }

    print("üß† Facts:", facts)

    # Phase 3 : moteur d‚Äôattaque
    chain = evaluate_chain(facts)

    print("\n--- ATTACK CHAIN ---")
    print(json.dumps(chain, indent=2))

    if not chain or not chain.get("exploit"):
        print("\n‚ö†Ô∏è Aucune exploitation r√©elle possible")
        return

    # Phase 4 : exploitation r√©elle
    print("\nüî• Exploit recommand√©:", chain["exploit"])

    runner = ExploitRunner()
    result = runner.run(chain["exploit"], target)

    print("\n--- REAL EXPLOIT RESULT ---")
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()
